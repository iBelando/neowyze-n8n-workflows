{
  "active": true,
  "connections": {
    "When chat message received": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "Basic LLM Chain",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "createdAt": "2025-08-21T00:40:10.194Z",
  "id": "IGfZZID7aGB2qpde",
  "isArchived": false,
  "meta": {
    "templateCredsSetupCompleted": true
  },
  "name": "[BerMich] Crypto Analyst Agent",
  "nodes": [
    {
      "parameters": {
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chatTrigger",
      "typeVersion": 1.3,
      "position": [
        0,
        0
      ],
      "id": "f5cd74cc-af89-476b-b3ae-8d62b9bdd26a",
      "name": "When chat message received",
      "webhookId": "69006327-09ab-4741-a867-e1f7efc03597"
    },
    {
      "parameters": {
        "url": "=https://api.kucoin.com/api/v1/market/candles?symbol={{ $json.chatInput.toUpperCase() }}-USDT&type=1hour\n",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        208,
        0
      ],
      "id": "510fbb17-fab1-47c7-8206-4e6d1d8b41bf",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "jsCode": "// 1) Ordenar cronológico (viejo -> nuevo)\nconst rows = items[0].json.data.slice().reverse();\n\n// 2) Mapear con el orden correcto de KuCoin: [t, open, close, high, low, volume, turnover]\nconst candles = rows.map(c => ({\n  time: Number(c[0]) * 1000,       // opcional: ms\n  open: Number(c[1]),\n  close: Number(c[2]),\n  high: Number(c[3]),\n  low: Number(c[4]),\n  volume: Number(c[5]),\n  turnover: Number(c[6])\n}));\n\nconst closes = candles.map(c => c.close);\nconst volumes = candles.map(c => c.volume);\n\n// EMA\nfunction ema(values, period) {\n  const k = 2 / (period + 1);\n  const seed = values.slice(0, period).reduce((a,b)=>a+b, 0) / period;\n  const out = new Array(values.length).fill(null);\n  out[period - 1] = seed;\n  for (let i = period; i < values.length; i++) {\n    out[i] = values[i] * k + out[i - 1] * (1 - k);\n  }\n  return out;\n}\n\n// RSI14\nfunction rsi(values, period = 14) {\n  const gains = [], losses = [];\n  for (let i = 1; i < values.length; i++) {\n    const ch = values[i] - values[i - 1];\n    gains.push(ch > 0 ? ch : 0);\n    losses.push(ch < 0 ? -ch : 0);\n  }\n  let avgG = gains.slice(0, period).reduce((a,b)=>a+b,0) / period;\n  let avgL = losses.slice(0, period).reduce((a,b)=>a+b,0) / period;\n  const out = new Array(values.length).fill(null);\n  for (let i = period; i < gains.length; i++) {\n    avgG = (avgG * (period - 1) + gains[i]) / period;\n    avgL = (avgL * (period - 1) + losses[i]) / period;\n    const rs = avgL === 0 ? Infinity : avgG / avgL;\n    out[i + 1] = 100 - (100 / (1 + rs));\n  }\n  return out;\n}\n\n// 3) Últimos valores (ya en cronológico)\nconst lastClose = closes.at(-1);\nconst lastEma5  = ema(closes, 5).at(-1);\nconst lastEma9  = ema(closes, 9).at(-1);\nconst lastEma21 = ema(closes, 21).at(-1);\nconst lastRsi14 = rsi(closes, 14).at(-1);\nconst lastVolume = volumes.at(-1);\n\n// Señales rápidas\nconst emaSignalShort =\n  lastEma5 > lastEma9 ? \"EMA5 > EMA9 → posible subida rápida\" :\n  lastEma5 < lastEma9 ? \"EMA5 < EMA9 → posible bajada rápida\" :\n  \"EMA5 ≈ EMA9 → indeciso\";\n\nconst rsiSignalShort =\n  lastRsi14 > 70 ? \"RSI14 sobre 70 → sobrecompra\" :\n  lastRsi14 < 30 ? \"RSI14 bajo 30 → sobreventa\" :\n  \"RSI14 neutral\";\n\nconst avgVolume5 = volumes.slice(-5).reduce((a,b)=>a+b,0) / 5;\nconst volumeSignal5 = lastVolume > avgVolume5 * 1.2\n  ? \"Volumen alto → impulso\"\n  : \"Volumen normal/bajo → sin impulso\";\n\nconst momentumShort = lastClose - (closes.slice(-4, -1).reduce((a,b)=>a+b,0) / 3);\n\n// --- Cálculo de soporte y resistencia (TP numérico) ---\nconst N = 20;\nconst closesN = closes.slice(-N);\nconst soporte = Math.min(...closesN);       // TP para Short\nconst resistencia = Math.max(...closesN);   // TP para Long\n\nreturn [{\n  json: {\n    lastClose,\n    lastEma5,\n    lastEma9,\n    lastEma21,\n    lastRsi14,\n    lastVolume,\n    avgVolume5,\n    momentumShort,\n    emaSignalShort,\n    rsiSignalShort,\n    volumeSignal5,\n    soporte,\n    resistencia\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        416,
        0
      ],
      "id": "bd598834-9868-47f7-955f-ab207850fc93",
      "name": "Code"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=Analiza {{ $('When chat message received').item.json.chatInput.toUpperCase() }} en timeframe de 1 hora con los siguientes datos:\n\nPrecio actual: {{ $json.lastClose }}\nEMA5: {{ $json.lastEma5 }} ({{ $json.emaSignalShort }}) \nEMA9: {{ $json.lastEma9 }} \nEMA21: {{ $json.lastEma21 }} \nRSI14: {{ $json.lastRsi14 }} ({{ $json.rsiSignalShort }}) Volumen: {{ $json.lastVolume }} (prom5: {{ $json.avgVolume5 }}, {{ $json.volumeSignal5 }}) \nMomentum corto: {{ $json.momentumShort }} \n\nDa una única recomendación inmediata en **exactamente uno** de estos tres formatos, sin agregar palabras adicionales ni explicaciones fuera del corchete: \n\n- Long en X con objetivo Y porque [razón concreta] \n- Short en X con objetivo Y porque [razón concreta] \n- Esperar en X porque [razón concreta] \n\nDonde: \n- X = {{ $json.lastClose }} \n- Y = resistencia cercana si es Long o soporte cercano si es Short. \n\n- Reglas: \n1. Si volumen < promedio5 → siempre \"Esperar\". \n2. Si RSI > 65 → \"Short\" (si EMA y Momentum no contradicen). \n3. Si RSI < 35 → \"Long\" (si EMA y Momentum no contradicen). \n4. Si RSI neutral: \n- Si EMA5 > EMA9 y Momentum > 0 → \"Long\". \n- Si EMA5 < EMA9 y Momentum < 0 → \"Short\". \n5. Solo \"Esperar\" si volumen es bajo o las señales son totalmente contradictorias. \n\nNo uses frases vagas como \"alrededor de la resistencia cercana\" → escribe siempre **solo \"resistencia cercana\" o \"soporte cercano\"**.",
        "batching": {}
      },
      "type": "@n8n/n8n-nodes-langchain.chainLlm",
      "typeVersion": 1.7,
      "position": [
        624,
        0
      ],
      "id": "ebf8d64c-069f-4f5c-af0e-cc6f18bddc67",
      "name": "Basic LLM Chain"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-nano",
          "mode": "list",
          "cachedResultName": "gpt-4.1-nano"
        },
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.2,
      "position": [
        624,
        160
      ],
      "id": "bf9721c5-28d0-44dd-98ad-388ae5f1675a",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "WXcb81sSca2QEiC8",
          "name": "Neowyze OpenAI Credentials"
        }
      }
    }
  ],
  "pinData": {},
  "settings": {
    "executionOrder": "v1"
  },
  "staticData": null,
  "tags": [],
  "triggerCount": 1,
  "updatedAt": "2025-09-20T13:18:14.000Z",
  "versionId": "f7383158-19d8-4523-821b-23e7c59411e9"
}